# Здесь приведен список используемых аннотаций, а так же краткие комментарии

## Аннотации компонентов 

- @Core - Ядро фрэймворка. Не дает никаких преимуществ при использовании в других классах.

- @Component - Декларирует класс к использованию. 
 Он будет являться частью графа (компонентом) и участвовать в топологической сортировке. 
 Фрэймворк будет создавать его инстанс при запросе через resolve, 
 либо если какой либо из компонентов требует его внедрения.

- @Repository - это @Component. Различие семантическое. 
 По задумке, это классы, выполняющие какие-либо операции с базой данных.

- @Service - это @Component. Различие семантическое. 
 По задумке, это классы, которые содержат бизнес-логику (а так же чаще всего они используют репозитории для CRUD).

- @Interceptor - это @Component. Плюс класс дополнительно помечается, 
 как перехватчик before/after методов для proxy объектов. Класс interceptor обязан реализовать интерфейс 
 zif_di_proxy_interceptor и быть единственным в рамках сканируемых пакетов.

- @Configuration - не является компонентом. Аннотация нужна, чтобы класс попал в сканнер. 
Класс конфигурации обязан реализовать интерфейс zif_di_app_config_enhancer.
После обнаружения, фрэймворк вызовет метод zif_di_app_config_enhancer~configurate, 
передав объект конфигуратора (zif_di_app_config). После этого жизненный цикл класса @Configuration завершается, 
его инстанс уничтожается.
Классов конфигураторов может быть сколько угодно в рамках сканируемых пакетов, 
но их настройки могут конфликтовать и порядок вызова не гарантирован.

Иерархически можно представить аннотации компонентов так:

```dotenv
|- @Configuration
|- @Component
|--- @Core
|--- @Repository
|--- @Service
|--- @Interceptor
```

## Аннотации области видимости, которые определяют жизненный цикл компонентов

- @Scope( Singleton ) - Один инстанс на всё приложение. Повторно не создается. Аннотацию можно не указывать, т.к. по умолчанию область видимости для любого компонента - Singleton.
- @Scope( Prototype ) - Новый инстанс при каждом запросе объекта. Каждый раз, когда объект затребован к внедрению, создается новый инстанс. Если объект тоже содержит зависимости и они имеют @Scope( Prototype ) - они так же будут созданы заново.

## Квалификатор для компонента

Если однотипных компонентов в приложении несколько, а так бывает зачастую. Можно и нужно указать квалификатор,
который позволит однозначно идентифицировать компонент.

- @Qualifier( QualifierValue )

Qualifier используется только для @Component. Например 

@Component
@Qualifier( HttpService )
zcl_service DEFINFITION.
ENDCLASS.

## Пометка к внедрению зависимости

Атрибуты класса, независимо от модификатора доступа, могут быть внедрены автоматически в класс через конструктор класса.
Для этого атрибут класса должен быть отмечен через аннотацию

- @Inject( <constructor_parameter_name> )

И конструктор класса должен иметь параметр <constructor_parameter_name>:

```abap
"@Component
CLASS zcl_demo_inject DEFINITION.
	PUBLIC SECTION.
	  METHODS:
	    constructor
		  IMPORTING
		    io_service TYPE REF TO service.
    PROTECTED SECTION.
	  "@Inject( io_service )
	  DATA mo_service TYPE REF TO zif_service.
ENDCLASS.
```
	  
При этом, в самой аннотации @Inject, указание значения <constructor_parameter_name> не обязательно. 
Если его не указать, то фрэймворк будет ожидать у конструктора имя параметра, аналогичное имени атрибута.

```abap
"@Component
CLASS zcl_demo_inject DEFINITION.
	PUBLIC SECTION.
	  METHODS:
	    constructor
		  IMPORTING
		    mo_service TYPE REF TO service.
    PROTECTED SECTION.
	  "@Inject
	  DATA mo_service TYPE REF TO zif_service.
ENDCLASS.
```

## Квалификатор для зависимости

Квалификатор зависимости позволяет указать конкретную реализацию, которую нужно внедрить.
Используется в сочетании с аннотацией @Inject.

- @RefQualifier( HttpService )

Для успеха операции в контейнере должен существовать @Component, имеющий квалификатор HttpService, 
т.е. @Qualifier( HttpService )

Пример:

```abap
@Component
@Qualifier( HttpService )
zcl_service DEFINFITION.
	PUBLIC SECTION.
	  INTERFACES zif_service.
ENDCLASS.

CLASS zcl_demo_inject DEFINITION.
	PUBLIC SECTION.
	  METHODS:
	    constructor
		  IMPORTING
		    io_service TYPE REF TO service.
    PROTECTED SECTION.
	  "@Inject( io_service )
	  "@RefQualifier( HttpService )
	  DATA mo_service TYPE REF TO zif_service.
ENDCLASS.
```

## Работа с объектом через прокси класс (Interceptor)

Это работает только с классами, которые реализуют хотя бы один интерфейс.
Каждый компонент, который реализует интерфейс, может быть проксирован.

- @Proxy( true ) | @Proxy( false )

Для перехвата методов, на уровне фрэймворка используется transient генерация (GENERATE SUBROUTINE POOL) 
класса zcl_aop_base.
Генерируется прокси класс с аналогичным интерфейсом, в прокси класс передается объект оригинал.
При сборке зависимстей контейнер видит, что класс нужно проксировать и отдает вместо оригинала - объект интерфейса,
который был создан при генерации. 
Вызов любого метода проксированного объекта передает управление классу, отмеченному как @Interceptor, 
и реализующему интерфейс zif_di_proxy_interceptorю
Клиент при этом считает, что работает с оригиналом, т.к. интерфейс не изменен.
На деле имеем возможность выполнять логирование, делать снимки памяти и прочее.